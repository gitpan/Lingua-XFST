# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.3
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Lingua::XFST::Privates;
use base qw(Exporter);
use base qw(DynaLoader);
package Lingua::XFST::Privatesc;
bootstrap Lingua::XFST::Privates;
package Lingua::XFST::Privates;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Lingua::XFST::Privates;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Lingua::XFST::Privates;

*libcfsm_version = *Lingua::XFST::Privatesc::libcfsm_version;
*libcfsm_build = *Lingua::XFST::Privatesc::libcfsm_build;
*make_fat_string = *Lingua::XFST::Privatesc::make_fat_string;
*fat_strcpy = *Lingua::XFST::Privatesc::fat_strcpy;
*copy_fat_string = *Lingua::XFST::Privatesc::copy_fat_string;
*fat_strcat = *Lingua::XFST::Privatesc::fat_strcat;
*fat_to_thin_str = *Lingua::XFST::Privatesc::fat_to_thin_str;
*fprint_fat_string = *Lingua::XFST::Privatesc::fprint_fat_string;
*make_string_buffer = *Lingua::XFST::Privatesc::make_string_buffer;
*make_fat_str_buffer = *Lingua::XFST::Privatesc::make_fat_str_buffer;
*free_string_buffer = *Lingua::XFST::Privatesc::free_string_buffer;
*initialize_string_buffer = *Lingua::XFST::Privatesc::initialize_string_buffer;
*append_string_to_buffer = *Lingua::XFST::Privatesc::append_string_to_buffer;
*append_label_to_buffer = *Lingua::XFST::Privatesc::append_label_to_buffer;
*append_fat_str_to_buffer = *Lingua::XFST::Privatesc::append_fat_str_to_buffer;
*assure_buffer_space = *Lingua::XFST::Privatesc::assure_buffer_space;
*print_string_buffer = *Lingua::XFST::Privatesc::print_string_buffer;
*make_lab_vector = *Lingua::XFST::Privatesc::make_lab_vector;
*reclaim_lab_vector = *Lingua::XFST::Privatesc::reclaim_lab_vector;
*append_to_lab_vector = *Lingua::XFST::Privatesc::append_to_lab_vector;
*set_lab_vector_element_at = *Lingua::XFST::Privatesc::set_lab_vector_element_at;
*lab_vector_element_at = *Lingua::XFST::Privatesc::lab_vector_element_at;
*increment_lab_vector = *Lingua::XFST::Privatesc::increment_lab_vector;
*decrement_lab_vector = *Lingua::XFST::Privatesc::decrement_lab_vector;
*reset_lab_vector = *Lingua::XFST::Privatesc::reset_lab_vector;
*make_vector = *Lingua::XFST::Privatesc::make_vector;
*free_vector = *Lingua::XFST::Privatesc::free_vector;
*append_to_vector = *Lingua::XFST::Privatesc::append_to_vector;
*vector_element_at = *Lingua::XFST::Privatesc::vector_element_at;
*set_vector_element_at = *Lingua::XFST::Privatesc::set_vector_element_at;
*reset_vector = *Lingua::XFST::Privatesc::reset_vector;
*print_label = *Lingua::XFST::Privatesc::print_label;
*single_to_id = *Lingua::XFST::Privatesc::single_to_id;
*pair_to_id = *Lingua::XFST::Privatesc::pair_to_id;
*id_pair_to_id = *Lingua::XFST::Privatesc::id_pair_to_id;
*id_to_label = *Lingua::XFST::Privatesc::id_to_label;
*upper_id = *Lingua::XFST::Privatesc::upper_id;
*lower_id = *Lingua::XFST::Privatesc::lower_id;
*make_alph = *Lingua::XFST::Privatesc::make_alph;
*copy_alphabet = *Lingua::XFST::Privatesc::copy_alphabet;
*free_alph = *Lingua::XFST::Privatesc::free_alph;
*print_alph = *Lingua::XFST::Privatesc::print_alph;
*start_alph_iterator = *Lingua::XFST::Privatesc::start_alph_iterator;
*next_alph_id = *Lingua::XFST::Privatesc::next_alph_id;
*reset_alph_iterator = *Lingua::XFST::Privatesc::reset_alph_iterator;
*free_alph_iterator = *Lingua::XFST::Privatesc::free_alph_iterator;
*free_arc = *Lingua::XFST::Privatesc::free_arc;
*free_state = *Lingua::XFST::Privatesc::free_state;
*make_empty_net = *Lingua::XFST::Privatesc::make_empty_net;
*copy_net = *Lingua::XFST::Privatesc::copy_net;
*minimize_net = *Lingua::XFST::Privatesc::minimize_net;
*free_network = *Lingua::XFST::Privatesc::free_network;
*print_net = *Lingua::XFST::Privatesc::print_net;
*add_state_to_net = *Lingua::XFST::Privatesc::add_state_to_net;
*add_arc_to_state = *Lingua::XFST::Privatesc::add_arc_to_state;
*read_net_properties = *Lingua::XFST::Privatesc::read_net_properties;
*write_net_properties = *Lingua::XFST::Privatesc::write_net_properties;
*add_string_property = *Lingua::XFST::Privatesc::add_string_property;
*get_string_property = *Lingua::XFST::Privatesc::get_string_property;
*remove_string_property = *Lingua::XFST::Privatesc::remove_string_property;
*make_nv = *Lingua::XFST::Privatesc::make_nv;
*net2nv = *Lingua::XFST::Privatesc::net2nv;
*nv_get = *Lingua::XFST::Privatesc::nv_get;
*nv_push = *Lingua::XFST::Privatesc::nv_push;
*nv_add = *Lingua::XFST::Privatesc::nv_add;
*free_nv_only = *Lingua::XFST::Privatesc::free_nv_only;
*free_nv_and_nets = *Lingua::XFST::Privatesc::free_nv_and_nets;
*watch_margin = *Lingua::XFST::Privatesc::watch_margin;
*int_print_length = *Lingua::XFST::Privatesc::int_print_length;
*label_length = *Lingua::XFST::Privatesc::label_length;
*new_page = *Lingua::XFST::Privatesc::new_page;
*make_page = *Lingua::XFST::Privatesc::make_page;
*free_page = *Lingua::XFST::Privatesc::free_page;
*reset_page = *Lingua::XFST::Privatesc::reset_page;
*print_page = *Lingua::XFST::Privatesc::print_page;
*new_page_line = *Lingua::XFST::Privatesc::new_page_line;
*char_to_page = *Lingua::XFST::Privatesc::char_to_page;
*int_to_page = *Lingua::XFST::Privatesc::int_to_page;
*float_to_page = *Lingua::XFST::Privatesc::float_to_page;
*spaces_to_page = *Lingua::XFST::Privatesc::spaces_to_page;
*string_to_page = *Lingua::XFST::Privatesc::string_to_page;
*fat_string_to_page = *Lingua::XFST::Privatesc::fat_string_to_page;
*fat_string_to_page_esc = *Lingua::XFST::Privatesc::fat_string_to_page_esc;
*symbol_to_page = *Lingua::XFST::Privatesc::symbol_to_page;
*label_to_page = *Lingua::XFST::Privatesc::label_to_page;
*labels_to_page = *Lingua::XFST::Privatesc::labels_to_page;
*sigma_to_page = *Lingua::XFST::Privatesc::sigma_to_page;
*network_to_page = *Lingua::XFST::Privatesc::network_to_page;
*words_to_page = *Lingua::XFST::Privatesc::words_to_page;
*random_words_to_page = *Lingua::XFST::Privatesc::random_words_to_page;
*alphabet_to_page = *Lingua::XFST::Privatesc::alphabet_to_page;
*flags_to_page = *Lingua::XFST::Privatesc::flags_to_page;
*properties_to_page = *Lingua::XFST::Privatesc::properties_to_page;
*net_size_to_page = *Lingua::XFST::Privatesc::net_size_to_page;
*time_to_page = *Lingua::XFST::Privatesc::time_to_page;
*label_vector_to_page = *Lingua::XFST::Privatesc::label_vector_to_page;
*symbol_list_to_page = *Lingua::XFST::Privatesc::symbol_list_to_page;
*file_info_to_page = *Lingua::XFST::Privatesc::file_info_to_page;
*storage_info_to_page = *Lingua::XFST::Privatesc::storage_info_to_page;
*longest_string_to_page = *Lingua::XFST::Privatesc::longest_string_to_page;
*shortest_string_to_page = *Lingua::XFST::Privatesc::shortest_string_to_page;
*get_default_cfsm_context = *Lingua::XFST::Privatesc::get_default_cfsm_context;
*check_for_input_encoding = *Lingua::XFST::Privatesc::check_for_input_encoding;
*set_char_encoding = *Lingua::XFST::Privatesc::set_char_encoding;
*init_arc_iterator = *Lingua::XFST::Privatesc::init_arc_iterator;
*start_arc_iterator = *Lingua::XFST::Privatesc::start_arc_iterator;
*next_iterator_arc = *Lingua::XFST::Privatesc::next_iterator_arc;
*free_arc_iterator = *Lingua::XFST::Privatesc::free_arc_iterator;
*new_tokenizer = *Lingua::XFST::Privatesc::new_tokenizer;
*make_tokenizer = *Lingua::XFST::Privatesc::make_tokenizer;
*next_token_net = *Lingua::XFST::Privatesc::next_token_net;
*free_tokenizer = *Lingua::XFST::Privatesc::free_tokenizer;
*initialize_cfsm = *Lingua::XFST::Privatesc::initialize_cfsm;
*reclaim_cfsm = *Lingua::XFST::Privatesc::reclaim_cfsm;
*int_parameters = *Lingua::XFST::Privatesc::int_parameters;
*save_net = *Lingua::XFST::Privatesc::save_net;
*save_nets = *Lingua::XFST::Privatesc::save_nets;
*save_defined_nets = *Lingua::XFST::Privatesc::save_defined_nets;
*load_net = *Lingua::XFST::Privatesc::load_net;
*load_nets = *Lingua::XFST::Privatesc::load_nets;
*load_defined_nets = *Lingua::XFST::Privatesc::load_defined_nets;
*load_defined_net = *Lingua::XFST::Privatesc::load_defined_net;
*string_to_net = *Lingua::XFST::Privatesc::string_to_net;
*read_text = *Lingua::XFST::Privatesc::read_text;
*read_spaced_text = *Lingua::XFST::Privatesc::read_spaced_text;
*read_regex = *Lingua::XFST::Privatesc::read_regex;
*read_lexc = *Lingua::XFST::Privatesc::read_lexc;
*read_prolog = *Lingua::XFST::Privatesc::read_prolog;
*write_text = *Lingua::XFST::Privatesc::write_text;
*write_text_to_page = *Lingua::XFST::Privatesc::write_text_to_page;
*write_spaced_text = *Lingua::XFST::Privatesc::write_spaced_text;
*write_spaced_text_to_page = *Lingua::XFST::Privatesc::write_spaced_text_to_page;
*write_prolog = *Lingua::XFST::Privatesc::write_prolog;
*init_apply = *Lingua::XFST::Privatesc::init_apply;
*apply_to_string = *Lingua::XFST::Privatesc::apply_to_string;
*switch_input_side = *Lingua::XFST::Privatesc::switch_input_side;
*new_applyer = *Lingua::XFST::Privatesc::new_applyer;
*make_applyer = *Lingua::XFST::Privatesc::make_applyer;
*next_apply_output = *Lingua::XFST::Privatesc::next_apply_output;
*init_apply_to_string = *Lingua::XFST::Privatesc::init_apply_to_string;
*init_apply_to_stream = *Lingua::XFST::Privatesc::init_apply_to_stream;
*free_applyer = *Lingua::XFST::Privatesc::free_applyer;
*free_applyer_complete = *Lingua::XFST::Privatesc::free_applyer_complete;
*test_lower_bounded = *Lingua::XFST::Privatesc::test_lower_bounded;
*test_upper_bounded = *Lingua::XFST::Privatesc::test_upper_bounded;
*test_non_null = *Lingua::XFST::Privatesc::test_non_null;
*test_upper_universal = *Lingua::XFST::Privatesc::test_upper_universal;
*test_lower_universal = *Lingua::XFST::Privatesc::test_lower_universal;
*test_equivalent = *Lingua::XFST::Privatesc::test_equivalent;
*test_sublanguage = *Lingua::XFST::Privatesc::test_sublanguage;
*test_intersect = *Lingua::XFST::Privatesc::test_intersect;
*define_net = *Lingua::XFST::Privatesc::define_net;
*define_regex_net = *Lingua::XFST::Privatesc::define_regex_net;
*undefine_net = *Lingua::XFST::Privatesc::undefine_net;
*get_net = *Lingua::XFST::Privatesc::get_net;
*net = *Lingua::XFST::Privatesc::net;
*define_regex_list = *Lingua::XFST::Privatesc::define_regex_list;
*define_symbol_list = *Lingua::XFST::Privatesc::define_symbol_list;
*get_symbol_list = *Lingua::XFST::Privatesc::get_symbol_list;
*symbol_list = *Lingua::XFST::Privatesc::symbol_list;
*undefine_symbol_list = *Lingua::XFST::Privatesc::undefine_symbol_list;
*define_function = *Lingua::XFST::Privatesc::define_function;
*null_net = *Lingua::XFST::Privatesc::null_net;
*epsilon_net = *Lingua::XFST::Privatesc::epsilon_net;
*kleene_star_net = *Lingua::XFST::Privatesc::kleene_star_net;
*kleene_plus_net = *Lingua::XFST::Privatesc::kleene_plus_net;
*label_net = *Lingua::XFST::Privatesc::label_net;
*symbol_net = *Lingua::XFST::Privatesc::symbol_net;
*pair_net = *Lingua::XFST::Privatesc::pair_net;
*alphabet_net = *Lingua::XFST::Privatesc::alphabet_net;
*net_sigma = *Lingua::XFST::Privatesc::net_sigma;
*net_labels = *Lingua::XFST::Privatesc::net_labels;
*update_net_labels_and_sigma = *Lingua::XFST::Privatesc::update_net_labels_and_sigma;
*substitute_symbol = *Lingua::XFST::Privatesc::substitute_symbol;
*substitute_label = *Lingua::XFST::Privatesc::substitute_label;
*substitute_net = *Lingua::XFST::Privatesc::substitute_net;
*close_net_alphabet = *Lingua::XFST::Privatesc::close_net_alphabet;
*eliminate_flag = *Lingua::XFST::Privatesc::eliminate_flag;
*alph_add_to = *Lingua::XFST::Privatesc::alph_add_to;
*alph_remove_from = *Lingua::XFST::Privatesc::alph_remove_from;
*union_alph = *Lingua::XFST::Privatesc::union_alph;
*intersect_alph = *Lingua::XFST::Privatesc::intersect_alph;
*minus_alph = *Lingua::XFST::Privatesc::minus_alph;
*binary_to_label = *Lingua::XFST::Privatesc::binary_to_label;
*label_to_binary = *Lingua::XFST::Privatesc::label_to_binary;
*test_equal_alphs = *Lingua::XFST::Privatesc::test_equal_alphs;
*test_alph_member = *Lingua::XFST::Privatesc::test_alph_member;
*lower_side_net = *Lingua::XFST::Privatesc::lower_side_net;
*upper_side_net = *Lingua::XFST::Privatesc::upper_side_net;
*invert_net = *Lingua::XFST::Privatesc::invert_net;
*reverse_net = *Lingua::XFST::Privatesc::reverse_net;
*contains_net = *Lingua::XFST::Privatesc::contains_net;
*optional_net = *Lingua::XFST::Privatesc::optional_net;
*zero_plus_net = *Lingua::XFST::Privatesc::zero_plus_net;
*one_plus_net = *Lingua::XFST::Privatesc::one_plus_net;
*negate_net = *Lingua::XFST::Privatesc::negate_net;
*other_than_net = *Lingua::XFST::Privatesc::other_than_net;
*shuffle_net = *Lingua::XFST::Privatesc::shuffle_net;
*substring_net = *Lingua::XFST::Privatesc::substring_net;
*repeat_net = *Lingua::XFST::Privatesc::repeat_net;
*concat_net = *Lingua::XFST::Privatesc::concat_net;
*union_net = *Lingua::XFST::Privatesc::union_net;
*intersect_net = *Lingua::XFST::Privatesc::intersect_net;
*minus_net = *Lingua::XFST::Privatesc::minus_net;
*compose_net = *Lingua::XFST::Privatesc::compose_net;
*crossproduct_net = *Lingua::XFST::Privatesc::crossproduct_net;
*ignore_net = *Lingua::XFST::Privatesc::ignore_net;
*priority_union_net = *Lingua::XFST::Privatesc::priority_union_net;
*lenient_compose_net = *Lingua::XFST::Privatesc::lenient_compose_net;
*close_sigma = *Lingua::XFST::Privatesc::close_sigma;
*set_error_function = *Lingua::XFST::Privatesc::set_error_function;
*set_warning_function = *Lingua::XFST::Privatesc::set_warning_function;

############# Class : Lingua::XFST::Privates::STRING_BUFFERtype ##############

package Lingua::XFST::Privates::STRING_BUFFERtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_char_size_get = *Lingua::XFST::Privatesc::STRING_BUFFERtype_char_size_get;
*swig_char_size_set = *Lingua::XFST::Privatesc::STRING_BUFFERtype_char_size_set;
*swig_length_get = *Lingua::XFST::Privatesc::STRING_BUFFERtype_length_get;
*swig_length_set = *Lingua::XFST::Privatesc::STRING_BUFFERtype_length_set;
*swig_pos_get = *Lingua::XFST::Privatesc::STRING_BUFFERtype_pos_get;
*swig_pos_set = *Lingua::XFST::Privatesc::STRING_BUFFERtype_pos_set;
*swig_lines_get = *Lingua::XFST::Privatesc::STRING_BUFFERtype_lines_get;
*swig_lines_set = *Lingua::XFST::Privatesc::STRING_BUFFERtype_lines_set;
*swig_string_get = *Lingua::XFST::Privatesc::STRING_BUFFERtype_string_get;
*swig_string_set = *Lingua::XFST::Privatesc::STRING_BUFFERtype_string_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_STRING_BUFFERtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_STRING_BUFFERtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::LAB_VECTORtype ##############

package Lingua::XFST::Privates::LAB_VECTORtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_length_get = *Lingua::XFST::Privatesc::LAB_VECTORtype_length_get;
*swig_length_set = *Lingua::XFST::Privatesc::LAB_VECTORtype_length_set;
*swig_pos_get = *Lingua::XFST::Privatesc::LAB_VECTORtype_pos_get;
*swig_pos_set = *Lingua::XFST::Privatesc::LAB_VECTORtype_pos_set;
*swig_array_get = *Lingua::XFST::Privatesc::LAB_VECTORtype_array_get;
*swig_array_set = *Lingua::XFST::Privatesc::LAB_VECTORtype_array_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_LAB_VECTORtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_LAB_VECTORtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::VECTORtype ##############

package Lingua::XFST::Privates::VECTORtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_length_get = *Lingua::XFST::Privatesc::VECTORtype_length_get;
*swig_length_set = *Lingua::XFST::Privatesc::VECTORtype_length_set;
*swig_pos_get = *Lingua::XFST::Privatesc::VECTORtype_pos_get;
*swig_pos_set = *Lingua::XFST::Privatesc::VECTORtype_pos_set;
*swig_array_get = *Lingua::XFST::Privatesc::VECTORtype_array_get;
*swig_array_set = *Lingua::XFST::Privatesc::VECTORtype_array_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_VECTORtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_VECTORtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::TUPLEtype ##############

package Lingua::XFST::Privates::TUPLEtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_labels_get = *Lingua::XFST::Privatesc::TUPLEtype_labels_get;
*swig_labels_set = *Lingua::XFST::Privatesc::TUPLEtype_labels_set;
*swig_inverse_get = *Lingua::XFST::Privatesc::TUPLEtype_inverse_get;
*swig_inverse_set = *Lingua::XFST::Privatesc::TUPLEtype_inverse_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_TUPLEtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_TUPLEtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FLAG_DIACRtype ##############

package Lingua::XFST::Privates::FLAG_DIACRtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_action_get = *Lingua::XFST::Privatesc::FLAG_DIACRtype_action_get;
*swig_action_set = *Lingua::XFST::Privatesc::FLAG_DIACRtype_action_set;
*swig_attribute_get = *Lingua::XFST::Privatesc::FLAG_DIACRtype_attribute_get;
*swig_attribute_set = *Lingua::XFST::Privatesc::FLAG_DIACRtype_attribute_set;
*swig_value_get = *Lingua::XFST::Privatesc::FLAG_DIACRtype_value_get;
*swig_value_set = *Lingua::XFST::Privatesc::FLAG_DIACRtype_value_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FLAG_DIACRtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FLAG_DIACRtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::LABELtype ##############

package Lingua::XFST::Privates::LABELtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_id_get = *Lingua::XFST::Privatesc::LABELtype_id_get;
*swig_id_set = *Lingua::XFST::Privatesc::LABELtype_id_set;
*swig_other_id_get = *Lingua::XFST::Privatesc::LABELtype_other_id_get;
*swig_other_id_set = *Lingua::XFST::Privatesc::LABELtype_other_id_set;
*swig_data_get = *Lingua::XFST::Privatesc::LABELtype_data_get;
*swig_data_set = *Lingua::XFST::Privatesc::LABELtype_data_set;
*swig_flag_get = *Lingua::XFST::Privatesc::LABELtype_flag_get;
*swig_flag_set = *Lingua::XFST::Privatesc::LABELtype_flag_set;
*swig_arity_get = *Lingua::XFST::Privatesc::LABELtype_arity_get;
*swig_arity_set = *Lingua::XFST::Privatesc::LABELtype_arity_set;
*swig_expands_other_get = *Lingua::XFST::Privatesc::LABELtype_expands_other_get;
*swig_expands_other_set = *Lingua::XFST::Privatesc::LABELtype_expands_other_set;
*swig_consumes_input_get = *Lingua::XFST::Privatesc::LABELtype_consumes_input_get;
*swig_consumes_input_set = *Lingua::XFST::Privatesc::LABELtype_consumes_input_set;
*swig_convertible_get = *Lingua::XFST::Privatesc::LABELtype_convertible_get;
*swig_convertible_set = *Lingua::XFST::Privatesc::LABELtype_convertible_set;
*swig_closing_xml_tag_get = *Lingua::XFST::Privatesc::LABELtype_closing_xml_tag_get;
*swig_closing_xml_tag_set = *Lingua::XFST::Privatesc::LABELtype_closing_xml_tag_set;
*swig_data_type_get = *Lingua::XFST::Privatesc::LABELtype_data_type_get;
*swig_data_type_set = *Lingua::XFST::Privatesc::LABELtype_data_type_set;
*swig_content_get = *Lingua::XFST::Privatesc::LABELtype_content_get;
*swig_content_set = *Lingua::XFST::Privatesc::LABELtype_content_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_LABELtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_LABELtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::LABELtype_content ##############

package Lingua::XFST::Privates::LABELtype_content;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_name_get = *Lingua::XFST::Privatesc::LABELtype_content_name_get;
*swig_name_set = *Lingua::XFST::Privatesc::LABELtype_content_name_set;
*swig_tuple_get = *Lingua::XFST::Privatesc::LABELtype_content_tuple_get;
*swig_tuple_set = *Lingua::XFST::Privatesc::LABELtype_content_tuple_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_LABELtype_content(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_LABELtype_content($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::ALPHABETtype ##############

package Lingua::XFST::Privates::ALPHABETtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_len_get = *Lingua::XFST::Privatesc::ALPHABETtype_len_get;
*swig_len_set = *Lingua::XFST::Privatesc::ALPHABETtype_len_set;
*swig_max_get = *Lingua::XFST::Privatesc::ALPHABETtype_max_get;
*swig_max_set = *Lingua::XFST::Privatesc::ALPHABETtype_max_set;
*swig_items_get = *Lingua::XFST::Privatesc::ALPHABETtype_items_get;
*swig_items_set = *Lingua::XFST::Privatesc::ALPHABETtype_items_set;
*swig_type_get = *Lingua::XFST::Privatesc::ALPHABETtype_type_get;
*swig_type_set = *Lingua::XFST::Privatesc::ALPHABETtype_type_set;
*swig_in_use_get = *Lingua::XFST::Privatesc::ALPHABETtype_in_use_get;
*swig_in_use_set = *Lingua::XFST::Privatesc::ALPHABETtype_in_use_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_ALPHABETtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_ALPHABETtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::ALPH_ITtype ##############

package Lingua::XFST::Privates::ALPH_ITtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_pos_get = *Lingua::XFST::Privatesc::ALPH_ITtype_pos_get;
*swig_pos_set = *Lingua::XFST::Privatesc::ALPH_ITtype_pos_set;
*swig_len_get = *Lingua::XFST::Privatesc::ALPH_ITtype_len_get;
*swig_len_set = *Lingua::XFST::Privatesc::ALPH_ITtype_len_set;
*swig_type_get = *Lingua::XFST::Privatesc::ALPH_ITtype_type_get;
*swig_type_set = *Lingua::XFST::Privatesc::ALPH_ITtype_type_set;
*swig_items_get = *Lingua::XFST::Privatesc::ALPH_ITtype_items_get;
*swig_items_set = *Lingua::XFST::Privatesc::ALPH_ITtype_items_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_ALPH_ITtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_ALPH_ITtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::PROPtype ##############

package Lingua::XFST::Privates::PROPtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_attribute_get = *Lingua::XFST::Privatesc::PROPtype_attribute_get;
*swig_attribute_set = *Lingua::XFST::Privatesc::PROPtype_attribute_set;
*swig_value_get = *Lingua::XFST::Privatesc::PROPtype_value_get;
*swig_value_set = *Lingua::XFST::Privatesc::PROPtype_value_set;
*swig_next_get = *Lingua::XFST::Privatesc::PROPtype_next_get;
*swig_next_set = *Lingua::XFST::Privatesc::PROPtype_next_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_PROPtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_PROPtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::ARCtype ##############

package Lingua::XFST::Privates::ARCtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_destination_get = *Lingua::XFST::Privatesc::ARCtype_destination_get;
*swig_destination_set = *Lingua::XFST::Privatesc::ARCtype_destination_set;
*swig_type_bit_get = *Lingua::XFST::Privatesc::ARCtype_type_bit_get;
*swig_type_bit_set = *Lingua::XFST::Privatesc::ARCtype_type_bit_set;
*swig_userflag1_get = *Lingua::XFST::Privatesc::ARCtype_userflag1_get;
*swig_userflag1_set = *Lingua::XFST::Privatesc::ARCtype_userflag1_set;
*swig_visit_mark_get = *Lingua::XFST::Privatesc::ARCtype_visit_mark_get;
*swig_visit_mark_set = *Lingua::XFST::Privatesc::ARCtype_visit_mark_set;
*swig_big_arc_flag_get = *Lingua::XFST::Privatesc::ARCtype_big_arc_flag_get;
*swig_big_arc_flag_set = *Lingua::XFST::Privatesc::ARCtype_big_arc_flag_set;
*swig_userflag2_get = *Lingua::XFST::Privatesc::ARCtype_userflag2_get;
*swig_userflag2_set = *Lingua::XFST::Privatesc::ARCtype_userflag2_set;
*swig_in_use_get = *Lingua::XFST::Privatesc::ARCtype_in_use_get;
*swig_in_use_set = *Lingua::XFST::Privatesc::ARCtype_in_use_set;
*swig_label_get = *Lingua::XFST::Privatesc::ARCtype_label_get;
*swig_label_set = *Lingua::XFST::Privatesc::ARCtype_label_set;
*swig_next_get = *Lingua::XFST::Privatesc::ARCtype_next_get;
*swig_next_set = *Lingua::XFST::Privatesc::ARCtype_next_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_ARCtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_ARCtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::BIG_ARCtype ##############

package Lingua::XFST::Privates::BIG_ARCtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_destination_get = *Lingua::XFST::Privatesc::BIG_ARCtype_destination_get;
*swig_destination_set = *Lingua::XFST::Privatesc::BIG_ARCtype_destination_set;
*swig_type_bit_get = *Lingua::XFST::Privatesc::BIG_ARCtype_type_bit_get;
*swig_type_bit_set = *Lingua::XFST::Privatesc::BIG_ARCtype_type_bit_set;
*swig_userflag1_get = *Lingua::XFST::Privatesc::BIG_ARCtype_userflag1_get;
*swig_userflag1_set = *Lingua::XFST::Privatesc::BIG_ARCtype_userflag1_set;
*swig_visit_mark_get = *Lingua::XFST::Privatesc::BIG_ARCtype_visit_mark_get;
*swig_visit_mark_set = *Lingua::XFST::Privatesc::BIG_ARCtype_visit_mark_set;
*swig_big_arc_flag_get = *Lingua::XFST::Privatesc::BIG_ARCtype_big_arc_flag_get;
*swig_big_arc_flag_set = *Lingua::XFST::Privatesc::BIG_ARCtype_big_arc_flag_set;
*swig_userflag2_get = *Lingua::XFST::Privatesc::BIG_ARCtype_userflag2_get;
*swig_userflag2_set = *Lingua::XFST::Privatesc::BIG_ARCtype_userflag2_set;
*swig_in_use_get = *Lingua::XFST::Privatesc::BIG_ARCtype_in_use_get;
*swig_in_use_set = *Lingua::XFST::Privatesc::BIG_ARCtype_in_use_set;
*swig_label_get = *Lingua::XFST::Privatesc::BIG_ARCtype_label_get;
*swig_label_set = *Lingua::XFST::Privatesc::BIG_ARCtype_label_set;
*swig_next_get = *Lingua::XFST::Privatesc::BIG_ARCtype_next_get;
*swig_next_set = *Lingua::XFST::Privatesc::BIG_ARCtype_next_set;
*swig_user_pointer_get = *Lingua::XFST::Privatesc::BIG_ARCtype_user_pointer_get;
*swig_user_pointer_set = *Lingua::XFST::Privatesc::BIG_ARCtype_user_pointer_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_BIG_ARCtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_BIG_ARCtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::STATEtype ##############

package Lingua::XFST::Privates::STATEtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_type_bit_get = *Lingua::XFST::Privatesc::STATEtype_type_bit_get;
*swig_type_bit_set = *Lingua::XFST::Privatesc::STATEtype_type_bit_set;
*swig_final_get = *Lingua::XFST::Privatesc::STATEtype_final_get;
*swig_final_set = *Lingua::XFST::Privatesc::STATEtype_final_set;
*swig_deterministic_get = *Lingua::XFST::Privatesc::STATEtype_deterministic_get;
*swig_deterministic_set = *Lingua::XFST::Privatesc::STATEtype_deterministic_set;
*swig_vector_p_get = *Lingua::XFST::Privatesc::STATEtype_vector_p_get;
*swig_vector_p_set = *Lingua::XFST::Privatesc::STATEtype_vector_p_set;
*swig_visit_mark_get = *Lingua::XFST::Privatesc::STATEtype_visit_mark_get;
*swig_visit_mark_set = *Lingua::XFST::Privatesc::STATEtype_visit_mark_set;
*swig_userflag2_get = *Lingua::XFST::Privatesc::STATEtype_userflag2_get;
*swig_userflag2_set = *Lingua::XFST::Privatesc::STATEtype_userflag2_set;
*swig_is_virtual_get = *Lingua::XFST::Privatesc::STATEtype_is_virtual_get;
*swig_is_virtual_set = *Lingua::XFST::Privatesc::STATEtype_is_virtual_set;
*swig_in_use_get = *Lingua::XFST::Privatesc::STATEtype_in_use_get;
*swig_in_use_set = *Lingua::XFST::Privatesc::STATEtype_in_use_set;
*swig_next_get = *Lingua::XFST::Privatesc::STATEtype_next_get;
*swig_next_set = *Lingua::XFST::Privatesc::STATEtype_next_set;
*swig_client_cell_get = *Lingua::XFST::Privatesc::STATEtype_client_cell_get;
*swig_client_cell_set = *Lingua::XFST::Privatesc::STATEtype_client_cell_set;
*swig_arc_get = *Lingua::XFST::Privatesc::STATEtype_arc_get;
*swig_arc_set = *Lingua::XFST::Privatesc::STATEtype_arc_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_STATEtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_STATEtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::STATEtype_arc ##############

package Lingua::XFST::Privates::STATEtype_arc;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_set_get = *Lingua::XFST::Privatesc::STATEtype_arc_set_get;
*swig_set_set = *Lingua::XFST::Privatesc::STATEtype_arc_set_set;
*swig_vector_get = *Lingua::XFST::Privatesc::STATEtype_arc_vector_get;
*swig_vector_set = *Lingua::XFST::Privatesc::STATEtype_arc_vector_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_STATEtype_arc(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_STATEtype_arc($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::NETtype ##############

package Lingua::XFST::Privates::NETtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_labels_get = *Lingua::XFST::Privatesc::NETtype_labels_get;
*swig_labels_set = *Lingua::XFST::Privatesc::NETtype_labels_set;
*swig_sigma_get = *Lingua::XFST::Privatesc::NETtype_sigma_get;
*swig_sigma_set = *Lingua::XFST::Privatesc::NETtype_sigma_set;
*swig_arc_label_arity_get = *Lingua::XFST::Privatesc::NETtype_arc_label_arity_get;
*swig_arc_label_arity_set = *Lingua::XFST::Privatesc::NETtype_arc_label_arity_set;
*swig_defined_as_get = *Lingua::XFST::Privatesc::NETtype_defined_as_get;
*swig_defined_as_set = *Lingua::XFST::Privatesc::NETtype_defined_as_set;
*swig_range_len_get = *Lingua::XFST::Privatesc::NETtype_range_len_get;
*swig_range_len_set = *Lingua::XFST::Privatesc::NETtype_range_len_set;
*swig_label_map_get = *Lingua::XFST::Privatesc::NETtype_label_map_get;
*swig_label_map_set = *Lingua::XFST::Privatesc::NETtype_label_map_set;
*swig_uprange_map_get = *Lingua::XFST::Privatesc::NETtype_uprange_map_get;
*swig_uprange_map_set = *Lingua::XFST::Privatesc::NETtype_uprange_map_set;
*swig_downrange_map_get = *Lingua::XFST::Privatesc::NETtype_downrange_map_get;
*swig_downrange_map_set = *Lingua::XFST::Privatesc::NETtype_downrange_map_set;
*swig_upmatch_table_get = *Lingua::XFST::Privatesc::NETtype_upmatch_table_get;
*swig_upmatch_table_set = *Lingua::XFST::Privatesc::NETtype_upmatch_table_set;
*swig_downmatch_table_get = *Lingua::XFST::Privatesc::NETtype_downmatch_table_get;
*swig_downmatch_table_set = *Lingua::XFST::Privatesc::NETtype_downmatch_table_set;
*swig_recode_key_get = *Lingua::XFST::Privatesc::NETtype_recode_key_get;
*swig_recode_key_set = *Lingua::XFST::Privatesc::NETtype_recode_key_set;
*swig_decode_key_get = *Lingua::XFST::Privatesc::NETtype_decode_key_get;
*swig_decode_key_set = *Lingua::XFST::Privatesc::NETtype_decode_key_set;
*swig_unreduce_key_get = *Lingua::XFST::Privatesc::NETtype_unreduce_key_get;
*swig_unreduce_key_set = *Lingua::XFST::Privatesc::NETtype_unreduce_key_set;
*swig_arc_vector_heap_get = *Lingua::XFST::Privatesc::NETtype_arc_vector_heap_get;
*swig_arc_vector_heap_set = *Lingua::XFST::Privatesc::NETtype_arc_vector_heap_set;
*swig_arc_vector_len_get = *Lingua::XFST::Privatesc::NETtype_arc_vector_len_get;
*swig_arc_vector_len_set = *Lingua::XFST::Privatesc::NETtype_arc_vector_len_set;
*swig_networkprops_get = *Lingua::XFST::Privatesc::NETtype_networkprops_get;
*swig_networkprops_set = *Lingua::XFST::Privatesc::NETtype_networkprops_set;
*swig_upper_parse_table_get = *Lingua::XFST::Privatesc::NETtype_upper_parse_table_get;
*swig_upper_parse_table_set = *Lingua::XFST::Privatesc::NETtype_upper_parse_table_set;
*swig_lower_parse_table_get = *Lingua::XFST::Privatesc::NETtype_lower_parse_table_get;
*swig_lower_parse_table_set = *Lingua::XFST::Privatesc::NETtype_lower_parse_table_set;
*swig_num_states_get = *Lingua::XFST::Privatesc::NETtype_num_states_get;
*swig_num_states_set = *Lingua::XFST::Privatesc::NETtype_num_states_set;
*swig_num_arcs_get = *Lingua::XFST::Privatesc::NETtype_num_arcs_get;
*swig_num_arcs_set = *Lingua::XFST::Privatesc::NETtype_num_arcs_set;
*swig_block_size_get = *Lingua::XFST::Privatesc::NETtype_block_size_get;
*swig_block_size_set = *Lingua::XFST::Privatesc::NETtype_block_size_set;
*swig_flag_register_get = *Lingua::XFST::Privatesc::NETtype_flag_register_get;
*swig_flag_register_set = *Lingua::XFST::Privatesc::NETtype_flag_register_set;
*swig_client_cell_get = *Lingua::XFST::Privatesc::NETtype_client_cell_get;
*swig_client_cell_set = *Lingua::XFST::Privatesc::NETtype_client_cell_set;
*swig_mmap_handle_get = *Lingua::XFST::Privatesc::NETtype_mmap_handle_get;
*swig_mmap_handle_set = *Lingua::XFST::Privatesc::NETtype_mmap_handle_set;
*swig_mmap_size_get = *Lingua::XFST::Privatesc::NETtype_mmap_size_get;
*swig_mmap_size_set = *Lingua::XFST::Privatesc::NETtype_mmap_size_set;
*swig_flags_get = *Lingua::XFST::Privatesc::NETtype_flags_get;
*swig_flags_set = *Lingua::XFST::Privatesc::NETtype_flags_set;
*swig_start_get = *Lingua::XFST::Privatesc::NETtype_start_get;
*swig_start_set = *Lingua::XFST::Privatesc::NETtype_start_set;
*swig_body_get = *Lingua::XFST::Privatesc::NETtype_body_get;
*swig_body_set = *Lingua::XFST::Privatesc::NETtype_body_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_NETtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_NETtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::NETtype_body ##############

package Lingua::XFST::Privates::NETtype_body;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_states_get = *Lingua::XFST::Privatesc::NETtype_body_states_get;
*swig_states_set = *Lingua::XFST::Privatesc::NETtype_body_states_set;
*swig_block_get = *Lingua::XFST::Privatesc::NETtype_body_block_get;
*swig_block_set = *Lingua::XFST::Privatesc::NETtype_body_block_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_NETtype_body(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_NETtype_body($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::NETtype_start ##############

package Lingua::XFST::Privates::NETtype_start;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_state_get = *Lingua::XFST::Privatesc::NETtype_start_state_get;
*swig_state_set = *Lingua::XFST::Privatesc::NETtype_start_state_set;
*swig_loc_get = *Lingua::XFST::Privatesc::NETtype_start_loc_get;
*swig_loc_set = *Lingua::XFST::Privatesc::NETtype_start_loc_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_NETtype_start(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_NETtype_start($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::NETtype_flags ##############

package Lingua::XFST::Privates::NETtype_flags;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_deterministic_get = *Lingua::XFST::Privatesc::NETtype_flags_deterministic_get;
*swig_deterministic_set = *Lingua::XFST::Privatesc::NETtype_flags_deterministic_set;
*swig_pruned_get = *Lingua::XFST::Privatesc::NETtype_flags_pruned_get;
*swig_pruned_set = *Lingua::XFST::Privatesc::NETtype_flags_pruned_set;
*swig_completed_get = *Lingua::XFST::Privatesc::NETtype_flags_completed_get;
*swig_completed_set = *Lingua::XFST::Privatesc::NETtype_flags_completed_set;
*swig_minimized_get = *Lingua::XFST::Privatesc::NETtype_flags_minimized_get;
*swig_minimized_set = *Lingua::XFST::Privatesc::NETtype_flags_minimized_set;
*swig_epsilon_free_get = *Lingua::XFST::Privatesc::NETtype_flags_epsilon_free_get;
*swig_epsilon_free_set = *Lingua::XFST::Privatesc::NETtype_flags_epsilon_free_set;
*swig_sorted_states_get = *Lingua::XFST::Privatesc::NETtype_flags_sorted_states_get;
*swig_sorted_states_set = *Lingua::XFST::Privatesc::NETtype_flags_sorted_states_set;
*swig_loop_free_get = *Lingua::XFST::Privatesc::NETtype_flags_loop_free_get;
*swig_loop_free_set = *Lingua::XFST::Privatesc::NETtype_flags_loop_free_set;
*swig_twol_net_get = *Lingua::XFST::Privatesc::NETtype_flags_twol_net_get;
*swig_twol_net_set = *Lingua::XFST::Privatesc::NETtype_flags_twol_net_set;
*swig_visit_marks_dirty_get = *Lingua::XFST::Privatesc::NETtype_flags_visit_marks_dirty_get;
*swig_visit_marks_dirty_set = *Lingua::XFST::Privatesc::NETtype_flags_visit_marks_dirty_set;
*swig_names_matter_get = *Lingua::XFST::Privatesc::NETtype_flags_names_matter_get;
*swig_names_matter_set = *Lingua::XFST::Privatesc::NETtype_flags_names_matter_set;
*swig_shared_arc_lists_get = *Lingua::XFST::Privatesc::NETtype_flags_shared_arc_lists_get;
*swig_shared_arc_lists_set = *Lingua::XFST::Privatesc::NETtype_flags_shared_arc_lists_set;
*swig_has_arc_user_pointer_get = *Lingua::XFST::Privatesc::NETtype_flags_has_arc_user_pointer_get;
*swig_has_arc_user_pointer_set = *Lingua::XFST::Privatesc::NETtype_flags_has_arc_user_pointer_set;
*swig_closed_sigma_get = *Lingua::XFST::Privatesc::NETtype_flags_closed_sigma_get;
*swig_closed_sigma_set = *Lingua::XFST::Privatesc::NETtype_flags_closed_sigma_set;
*swig_start_state_final_get = *Lingua::XFST::Privatesc::NETtype_flags_start_state_final_get;
*swig_start_state_final_set = *Lingua::XFST::Privatesc::NETtype_flags_start_state_final_set;
*swig_lower_bound_checked_get = *Lingua::XFST::Privatesc::NETtype_flags_lower_bound_checked_get;
*swig_lower_bound_checked_set = *Lingua::XFST::Privatesc::NETtype_flags_lower_bound_checked_set;
*swig_compacted_get = *Lingua::XFST::Privatesc::NETtype_flags_compacted_get;
*swig_compacted_set = *Lingua::XFST::Privatesc::NETtype_flags_compacted_set;
*swig_obsolete2_get = *Lingua::XFST::Privatesc::NETtype_flags_obsolete2_get;
*swig_obsolete2_set = *Lingua::XFST::Privatesc::NETtype_flags_obsolete2_set;
*swig_obsolete3_get = *Lingua::XFST::Privatesc::NETtype_flags_obsolete3_get;
*swig_obsolete3_set = *Lingua::XFST::Privatesc::NETtype_flags_obsolete3_set;
*swig_mark_get = *Lingua::XFST::Privatesc::NETtype_flags_mark_get;
*swig_mark_set = *Lingua::XFST::Privatesc::NETtype_flags_mark_set;
*swig_u_flag_diacr_get = *Lingua::XFST::Privatesc::NETtype_flags_u_flag_diacr_get;
*swig_u_flag_diacr_set = *Lingua::XFST::Privatesc::NETtype_flags_u_flag_diacr_set;
*swig_l_flag_diacr_get = *Lingua::XFST::Privatesc::NETtype_flags_l_flag_diacr_get;
*swig_l_flag_diacr_set = *Lingua::XFST::Privatesc::NETtype_flags_l_flag_diacr_set;
*swig_obsolete4_get = *Lingua::XFST::Privatesc::NETtype_flags_obsolete4_get;
*swig_obsolete4_set = *Lingua::XFST::Privatesc::NETtype_flags_obsolete4_set;
*swig_obsolete5_get = *Lingua::XFST::Privatesc::NETtype_flags_obsolete5_get;
*swig_obsolete5_set = *Lingua::XFST::Privatesc::NETtype_flags_obsolete5_set;
*swig_sorted_arcs_get = *Lingua::XFST::Privatesc::NETtype_flags_sorted_arcs_get;
*swig_sorted_arcs_set = *Lingua::XFST::Privatesc::NETtype_flags_sorted_arcs_set;
*swig_reduced_labelset_get = *Lingua::XFST::Privatesc::NETtype_flags_reduced_labelset_get;
*swig_reduced_labelset_set = *Lingua::XFST::Privatesc::NETtype_flags_reduced_labelset_set;
*swig_obsolete6_get = *Lingua::XFST::Privatesc::NETtype_flags_obsolete6_get;
*swig_obsolete6_set = *Lingua::XFST::Privatesc::NETtype_flags_obsolete6_set;
*swig_is_virtual_get = *Lingua::XFST::Privatesc::NETtype_flags_is_virtual_get;
*swig_is_virtual_set = *Lingua::XFST::Privatesc::NETtype_flags_is_virtual_set;
*swig_is_arc_optimized_get = *Lingua::XFST::Privatesc::NETtype_flags_is_arc_optimized_get;
*swig_is_arc_optimized_set = *Lingua::XFST::Privatesc::NETtype_flags_is_arc_optimized_set;
*swig_in_use_get = *Lingua::XFST::Privatesc::NETtype_flags_in_use_get;
*swig_in_use_set = *Lingua::XFST::Privatesc::NETtype_flags_in_use_set;
*swig_has_arc_vectors_get = *Lingua::XFST::Privatesc::NETtype_flags_has_arc_vectors_get;
*swig_has_arc_vectors_set = *Lingua::XFST::Privatesc::NETtype_flags_has_arc_vectors_set;
*swig_linear_bounded_upper_get = *Lingua::XFST::Privatesc::NETtype_flags_linear_bounded_upper_get;
*swig_linear_bounded_upper_set = *Lingua::XFST::Privatesc::NETtype_flags_linear_bounded_upper_set;
*swig_linear_bounded_lower_get = *Lingua::XFST::Privatesc::NETtype_flags_linear_bounded_lower_get;
*swig_linear_bounded_lower_set = *Lingua::XFST::Privatesc::NETtype_flags_linear_bounded_lower_set;
*swig_upper_bound_checked_get = *Lingua::XFST::Privatesc::NETtype_flags_upper_bound_checked_get;
*swig_upper_bound_checked_set = *Lingua::XFST::Privatesc::NETtype_flags_upper_bound_checked_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_NETtype_flags(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_NETtype_flags($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::NVtype ##############

package Lingua::XFST::Privates::NVtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_len_get = *Lingua::XFST::Privatesc::NVtype_len_get;
*swig_len_set = *Lingua::XFST::Privatesc::NVtype_len_set;
*swig_nets_get = *Lingua::XFST::Privatesc::NVtype_nets_get;
*swig_nets_set = *Lingua::XFST::Privatesc::NVtype_nets_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_NVtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_NVtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType ##############

package Lingua::XFST::Privates::IntParType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_regex_get = *Lingua::XFST::Privatesc::IntParType_regex_get;
*swig_regex_set = *Lingua::XFST::Privatesc::IntParType_regex_set;
*swig_command_line_get = *Lingua::XFST::Privatesc::IntParType_command_line_get;
*swig_command_line_set = *Lingua::XFST::Privatesc::IntParType_command_line_set;
*swig_alphabet_get = *Lingua::XFST::Privatesc::IntParType_alphabet_get;
*swig_alphabet_set = *Lingua::XFST::Privatesc::IntParType_alphabet_set;
*swig_general_get = *Lingua::XFST::Privatesc::IntParType_general_get;
*swig_general_set = *Lingua::XFST::Privatesc::IntParType_general_set;
*swig_optimization_get = *Lingua::XFST::Privatesc::IntParType_optimization_get;
*swig_optimization_set = *Lingua::XFST::Privatesc::IntParType_optimization_set;
*swig_io_get = *Lingua::XFST::Privatesc::IntParType_io_get;
*swig_io_set = *Lingua::XFST::Privatesc::IntParType_io_set;
*swig_parameters_get = *Lingua::XFST::Privatesc::IntParType_parameters_get;
*swig_parameters_set = *Lingua::XFST::Privatesc::IntParType_parameters_set;
*swig_seq_get = *Lingua::XFST::Privatesc::IntParType_seq_get;
*swig_seq_set = *Lingua::XFST::Privatesc::IntParType_seq_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_seq ##############

package Lingua::XFST::Privates::IntParType_seq;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_final_strings_arcs_get = *Lingua::XFST::Privatesc::IntParType_seq_final_strings_arcs_get;
*swig_final_strings_arcs_set = *Lingua::XFST::Privatesc::IntParType_seq_final_strings_arcs_set;
*swig_intern_strings_arcs_get = *Lingua::XFST::Privatesc::IntParType_seq_intern_strings_arcs_get;
*swig_intern_strings_arcs_set = *Lingua::XFST::Privatesc::IntParType_seq_intern_strings_arcs_set;
*swig_string_one_get = *Lingua::XFST::Privatesc::IntParType_seq_string_one_get;
*swig_string_one_set = *Lingua::XFST::Privatesc::IntParType_seq_string_one_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_seq(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_seq($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_parameters ##############

package Lingua::XFST::Privates::IntParType_parameters;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_interactive_get = *Lingua::XFST::Privatesc::IntParType_parameters_interactive_get;
*swig_interactive_set = *Lingua::XFST::Privatesc::IntParType_parameters_interactive_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_parameters(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_parameters($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_io ##############

package Lingua::XFST::Privates::IntParType_io;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_print_sigma_get = *Lingua::XFST::Privatesc::IntParType_io_print_sigma_get;
*swig_print_sigma_set = *Lingua::XFST::Privatesc::IntParType_io_print_sigma_set;
*swig_print_space_get = *Lingua::XFST::Privatesc::IntParType_io_print_space_get;
*swig_print_space_set = *Lingua::XFST::Privatesc::IntParType_io_print_space_set;
*swig_obey_flags_get = *Lingua::XFST::Privatesc::IntParType_io_obey_flags_get;
*swig_obey_flags_set = *Lingua::XFST::Privatesc::IntParType_io_obey_flags_set;
*swig_mark_version_get = *Lingua::XFST::Privatesc::IntParType_io_mark_version_get;
*swig_mark_version_set = *Lingua::XFST::Privatesc::IntParType_io_mark_version_set;
*swig_retokenize_get = *Lingua::XFST::Privatesc::IntParType_io_retokenize_get;
*swig_retokenize_set = *Lingua::XFST::Privatesc::IntParType_io_retokenize_set;
*swig_show_flags_get = *Lingua::XFST::Privatesc::IntParType_io_show_flags_get;
*swig_show_flags_set = *Lingua::XFST::Privatesc::IntParType_io_show_flags_set;
*swig_max_state_visits_get = *Lingua::XFST::Privatesc::IntParType_io_max_state_visits_get;
*swig_max_state_visits_set = *Lingua::XFST::Privatesc::IntParType_io_max_state_visits_set;
*swig_max_recursion_get = *Lingua::XFST::Privatesc::IntParType_io_max_recursion_get;
*swig_max_recursion_set = *Lingua::XFST::Privatesc::IntParType_io_max_recursion_set;
*swig_count_patterns_get = *Lingua::XFST::Privatesc::IntParType_io_count_patterns_get;
*swig_count_patterns_set = *Lingua::XFST::Privatesc::IntParType_io_count_patterns_set;
*swig_delete_patterns_get = *Lingua::XFST::Privatesc::IntParType_io_delete_patterns_get;
*swig_delete_patterns_set = *Lingua::XFST::Privatesc::IntParType_io_delete_patterns_set;
*swig_extract_patterns_get = *Lingua::XFST::Privatesc::IntParType_io_extract_patterns_get;
*swig_extract_patterns_set = *Lingua::XFST::Privatesc::IntParType_io_extract_patterns_set;
*swig_locate_patterns_get = *Lingua::XFST::Privatesc::IntParType_io_locate_patterns_get;
*swig_locate_patterns_set = *Lingua::XFST::Privatesc::IntParType_io_locate_patterns_set;
*swig_mark_patterns_get = *Lingua::XFST::Privatesc::IntParType_io_mark_patterns_get;
*swig_mark_patterns_set = *Lingua::XFST::Privatesc::IntParType_io_mark_patterns_set;
*swig_license_type_get = *Lingua::XFST::Privatesc::IntParType_io_license_type_get;
*swig_license_type_set = *Lingua::XFST::Privatesc::IntParType_io_license_type_set;
*swig_char_encoding_get = *Lingua::XFST::Privatesc::IntParType_io_char_encoding_get;
*swig_char_encoding_set = *Lingua::XFST::Privatesc::IntParType_io_char_encoding_set;
*swig_use_memory_map_get = *Lingua::XFST::Privatesc::IntParType_io_use_memory_map_get;
*swig_use_memory_map_set = *Lingua::XFST::Privatesc::IntParType_io_use_memory_map_set;
*swig_use_timer_get = *Lingua::XFST::Privatesc::IntParType_io_use_timer_get;
*swig_use_timer_set = *Lingua::XFST::Privatesc::IntParType_io_use_timer_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_io(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_io($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_optimization ##############

package Lingua::XFST::Privates::IntParType_optimization;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_in_order_get = *Lingua::XFST::Privatesc::IntParType_optimization_in_order_get;
*swig_in_order_set = *Lingua::XFST::Privatesc::IntParType_optimization_in_order_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_optimization(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_optimization($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_general ##############

package Lingua::XFST::Privates::IntParType_general;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_sort_arcs_get = *Lingua::XFST::Privatesc::IntParType_general_sort_arcs_get;
*swig_sort_arcs_set = *Lingua::XFST::Privatesc::IntParType_general_sort_arcs_set;
*swig_verbose_get = *Lingua::XFST::Privatesc::IntParType_general_verbose_get;
*swig_verbose_set = *Lingua::XFST::Privatesc::IntParType_general_verbose_set;
*swig_completion_get = *Lingua::XFST::Privatesc::IntParType_general_completion_get;
*swig_completion_set = *Lingua::XFST::Privatesc::IntParType_general_completion_set;
*swig_stack_get = *Lingua::XFST::Privatesc::IntParType_general_stack_get;
*swig_stack_set = *Lingua::XFST::Privatesc::IntParType_general_stack_set;
*swig_name_nets_get = *Lingua::XFST::Privatesc::IntParType_general_name_nets_get;
*swig_name_nets_set = *Lingua::XFST::Privatesc::IntParType_general_name_nets_set;
*swig_minimal_get = *Lingua::XFST::Privatesc::IntParType_general_minimal_get;
*swig_minimal_set = *Lingua::XFST::Privatesc::IntParType_general_minimal_set;
*swig_quit_on_fail_get = *Lingua::XFST::Privatesc::IntParType_general_quit_on_fail_get;
*swig_quit_on_fail_set = *Lingua::XFST::Privatesc::IntParType_general_quit_on_fail_set;
*swig_assert_get = *Lingua::XFST::Privatesc::IntParType_general_assert_get;
*swig_assert_set = *Lingua::XFST::Privatesc::IntParType_general_assert_set;
*swig_show_escape_get = *Lingua::XFST::Privatesc::IntParType_general_show_escape_get;
*swig_show_escape_set = *Lingua::XFST::Privatesc::IntParType_general_show_escape_set;
*swig_sq_final_arcs_get = *Lingua::XFST::Privatesc::IntParType_general_sq_final_arcs_get;
*swig_sq_final_arcs_set = *Lingua::XFST::Privatesc::IntParType_general_sq_final_arcs_set;
*swig_sq_intern_arcs_get = *Lingua::XFST::Privatesc::IntParType_general_sq_intern_arcs_get;
*swig_sq_intern_arcs_set = *Lingua::XFST::Privatesc::IntParType_general_sq_intern_arcs_set;
*swig_recursive_define_get = *Lingua::XFST::Privatesc::IntParType_general_recursive_define_get;
*swig_recursive_define_set = *Lingua::XFST::Privatesc::IntParType_general_recursive_define_set;
*swig_recursive_apply_get = *Lingua::XFST::Privatesc::IntParType_general_recursive_apply_get;
*swig_recursive_apply_set = *Lingua::XFST::Privatesc::IntParType_general_recursive_apply_set;
*swig_compose_flag_as_special_get = *Lingua::XFST::Privatesc::IntParType_general_compose_flag_as_special_get;
*swig_compose_flag_as_special_set = *Lingua::XFST::Privatesc::IntParType_general_compose_flag_as_special_set;
*swig_need_separators_get = *Lingua::XFST::Privatesc::IntParType_general_need_separators_get;
*swig_need_separators_set = *Lingua::XFST::Privatesc::IntParType_general_need_separators_set;
*swig_max_context_length_get = *Lingua::XFST::Privatesc::IntParType_general_max_context_length_get;
*swig_max_context_length_set = *Lingua::XFST::Privatesc::IntParType_general_max_context_length_set;
*swig_vectorize_n_get = *Lingua::XFST::Privatesc::IntParType_general_vectorize_n_get;
*swig_vectorize_n_set = *Lingua::XFST::Privatesc::IntParType_general_vectorize_n_set;
*swig_fail_safe_composition_get = *Lingua::XFST::Privatesc::IntParType_general_fail_safe_composition_get;
*swig_fail_safe_composition_set = *Lingua::XFST::Privatesc::IntParType_general_fail_safe_composition_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_general(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_general($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_alphabet ##############

package Lingua::XFST::Privates::IntParType_alphabet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_print_pairs_get = *Lingua::XFST::Privatesc::IntParType_alphabet_print_pairs_get;
*swig_print_pairs_set = *Lingua::XFST::Privatesc::IntParType_alphabet_print_pairs_set;
*swig_print_left_get = *Lingua::XFST::Privatesc::IntParType_alphabet_print_left_get;
*swig_print_left_set = *Lingua::XFST::Privatesc::IntParType_alphabet_print_left_set;
*swig_read_left_get = *Lingua::XFST::Privatesc::IntParType_alphabet_read_left_get;
*swig_read_left_set = *Lingua::XFST::Privatesc::IntParType_alphabet_read_left_set;
*swig_unicode_get = *Lingua::XFST::Privatesc::IntParType_alphabet_unicode_get;
*swig_unicode_set = *Lingua::XFST::Privatesc::IntParType_alphabet_unicode_set;
*swig_recode_cp1252_get = *Lingua::XFST::Privatesc::IntParType_alphabet_recode_cp1252_get;
*swig_recode_cp1252_set = *Lingua::XFST::Privatesc::IntParType_alphabet_recode_cp1252_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_alphabet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_alphabet($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_command_line ##############

package Lingua::XFST::Privates::IntParType_command_line;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_quiet_get = *Lingua::XFST::Privatesc::IntParType_command_line_quiet_get;
*swig_quiet_set = *Lingua::XFST::Privatesc::IntParType_command_line_quiet_set;
*swig_obey_ctrl_c_get = *Lingua::XFST::Privatesc::IntParType_command_line_obey_ctrl_c_get;
*swig_obey_ctrl_c_set = *Lingua::XFST::Privatesc::IntParType_command_line_obey_ctrl_c_set;
*swig_stop_get = *Lingua::XFST::Privatesc::IntParType_command_line_stop_get;
*swig_stop_set = *Lingua::XFST::Privatesc::IntParType_command_line_stop_set;
*swig_want_deps_get = *Lingua::XFST::Privatesc::IntParType_command_line_want_deps_get;
*swig_want_deps_set = *Lingua::XFST::Privatesc::IntParType_command_line_want_deps_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_command_line(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_command_line($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::IntParType_regex ##############

package Lingua::XFST::Privates::IntParType_regex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_lex_errors_get = *Lingua::XFST::Privatesc::IntParType_regex_lex_errors_get;
*swig_lex_errors_set = *Lingua::XFST::Privatesc::IntParType_regex_lex_errors_set;
*swig_lex_max_errors_get = *Lingua::XFST::Privatesc::IntParType_regex_lex_max_errors_get;
*swig_lex_max_errors_set = *Lingua::XFST::Privatesc::IntParType_regex_lex_max_errors_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_IntParType_regex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_IntParType_regex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::ERROR_STREAM ##############

package Lingua::XFST::Privates::ERROR_STREAM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_dummy_get = *Lingua::XFST::Privatesc::ERROR_STREAM_dummy_get;
*swig_dummy_set = *Lingua::XFST::Privatesc::ERROR_STREAM_dummy_set;
*swig_tempfile_get = *Lingua::XFST::Privatesc::ERROR_STREAM_tempfile_get;
*swig_tempfile_set = *Lingua::XFST::Privatesc::ERROR_STREAM_tempfile_set;
*swig_buffer_get = *Lingua::XFST::Privatesc::ERROR_STREAM_buffer_get;
*swig_buffer_set = *Lingua::XFST::Privatesc::ERROR_STREAM_buffer_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_ERROR_STREAM(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_ERROR_STREAM($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::PAGEtype ##############

package Lingua::XFST::Privates::PAGEtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_line_pos_get = *Lingua::XFST::Privatesc::PAGEtype_line_pos_get;
*swig_line_pos_set = *Lingua::XFST::Privatesc::PAGEtype_line_pos_set;
*swig_cur_pos_get = *Lingua::XFST::Privatesc::PAGEtype_cur_pos_get;
*swig_cur_pos_set = *Lingua::XFST::Privatesc::PAGEtype_cur_pos_set;
*swig_line_no_get = *Lingua::XFST::Privatesc::PAGEtype_line_no_get;
*swig_line_no_set = *Lingua::XFST::Privatesc::PAGEtype_line_no_set;
*swig_indent_get = *Lingua::XFST::Privatesc::PAGEtype_indent_get;
*swig_indent_set = *Lingua::XFST::Privatesc::PAGEtype_indent_set;
*swig_rm_get = *Lingua::XFST::Privatesc::PAGEtype_rm_get;
*swig_rm_set = *Lingua::XFST::Privatesc::PAGEtype_rm_set;
*swig_size_get = *Lingua::XFST::Privatesc::PAGEtype_size_get;
*swig_size_set = *Lingua::XFST::Privatesc::PAGEtype_size_set;
*swig_string_get = *Lingua::XFST::Privatesc::PAGEtype_string_get;
*swig_string_set = *Lingua::XFST::Privatesc::PAGEtype_string_set;
*swig_eol_string_get = *Lingua::XFST::Privatesc::PAGEtype_eol_string_get;
*swig_eol_string_set = *Lingua::XFST::Privatesc::PAGEtype_eol_string_set;
*swig_indent_char_get = *Lingua::XFST::Privatesc::PAGEtype_indent_char_get;
*swig_indent_char_set = *Lingua::XFST::Privatesc::PAGEtype_indent_char_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_PAGEtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_PAGEtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::LABEL_STATStype ##############

package Lingua::XFST::Privates::LABEL_STATStype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_max_label_get = *Lingua::XFST::Privatesc::LABEL_STATStype_max_label_get;
*swig_max_label_set = *Lingua::XFST::Privatesc::LABEL_STATStype_max_label_set;
*swig_tally_size_get = *Lingua::XFST::Privatesc::LABEL_STATStype_tally_size_get;
*swig_tally_size_set = *Lingua::XFST::Privatesc::LABEL_STATStype_tally_size_set;
*swig_tally_get = *Lingua::XFST::Privatesc::LABEL_STATStype_tally_get;
*swig_tally_set = *Lingua::XFST::Privatesc::LABEL_STATStype_tally_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_LABEL_STATStype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_LABEL_STATStype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT ##############

package Lingua::XFST::Privates::FST_CNTXT;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_mode_get = *Lingua::XFST::Privatesc::FST_CNTXT_mode_get;
*swig_mode_set = *Lingua::XFST::Privatesc::FST_CNTXT_mode_set;
*swig_reclaimable_get = *Lingua::XFST::Privatesc::FST_CNTXT_reclaimable_get;
*swig_reclaimable_set = *Lingua::XFST::Privatesc::FST_CNTXT_reclaimable_set;
*swig_copyright_string_get = *Lingua::XFST::Privatesc::FST_CNTXT_copyright_string_get;
*swig_copyright_string_set = *Lingua::XFST::Privatesc::FST_CNTXT_copyright_string_set;
*swig_compose_strategy_get = *Lingua::XFST::Privatesc::FST_CNTXT_compose_strategy_get;
*swig_compose_strategy_set = *Lingua::XFST::Privatesc::FST_CNTXT_compose_strategy_set;
*swig_execution_error_get = *Lingua::XFST::Privatesc::FST_CNTXT_execution_error_get;
*swig_execution_error_set = *Lingua::XFST::Privatesc::FST_CNTXT_execution_error_set;
*swig_in_character_encoding_get = *Lingua::XFST::Privatesc::FST_CNTXT_in_character_encoding_get;
*swig_in_character_encoding_set = *Lingua::XFST::Privatesc::FST_CNTXT_in_character_encoding_set;
*swig_out_character_encoding_get = *Lingua::XFST::Privatesc::FST_CNTXT_out_character_encoding_get;
*swig_out_character_encoding_set = *Lingua::XFST::Privatesc::FST_CNTXT_out_character_encoding_set;
*swig_errorstream_get = *Lingua::XFST::Privatesc::FST_CNTXT_errorstream_get;
*swig_errorstream_set = *Lingua::XFST::Privatesc::FST_CNTXT_errorstream_set;
*swig_interface_get = *Lingua::XFST::Privatesc::FST_CNTXT_interface_get;
*swig_interface_set = *Lingua::XFST::Privatesc::FST_CNTXT_interface_set;
*swig_label_stats_get = *Lingua::XFST::Privatesc::FST_CNTXT_label_stats_get;
*swig_label_stats_set = *Lingua::XFST::Privatesc::FST_CNTXT_label_stats_set;
*swig_temp_bufs_get = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_get;
*swig_temp_bufs_set = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_set;
*swig_flags_get = *Lingua::XFST::Privatesc::FST_CNTXT_flags_get;
*swig_flags_set = *Lingua::XFST::Privatesc::FST_CNTXT_flags_set;
*swig_pretty_print_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_get;
*swig_pretty_print_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_set;
*swig_index_get = *Lingua::XFST::Privatesc::FST_CNTXT_index_get;
*swig_index_set = *Lingua::XFST::Privatesc::FST_CNTXT_index_set;
*swig_parse_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_get;
*swig_parse_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_set;
*swig_bin_io_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_get;
*swig_bin_io_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_set;
*swig_define_get = *Lingua::XFST::Privatesc::FST_CNTXT_define_get;
*swig_define_set = *Lingua::XFST::Privatesc::FST_CNTXT_define_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT_define ##############

package Lingua::XFST::Privates::FST_CNTXT_define;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_net_table_get = *Lingua::XFST::Privatesc::FST_CNTXT_define_net_table_get;
*swig_net_table_set = *Lingua::XFST::Privatesc::FST_CNTXT_define_net_table_set;
*swig_set_table_get = *Lingua::XFST::Privatesc::FST_CNTXT_define_set_table_get;
*swig_set_table_set = *Lingua::XFST::Privatesc::FST_CNTXT_define_set_table_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT_define(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT_define($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT_bin_io ##############

package Lingua::XFST::Privates::FST_CNTXT_bin_io;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_altchain_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_altchain_p_get;
*swig_altchain_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_altchain_p_set;
*swig_status_bar_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_status_bar_p_get;
*swig_status_bar_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_status_bar_p_set;
*swig_status_bar_increment_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_status_bar_increment_get;
*swig_status_bar_increment_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_status_bar_increment_set;
*swig_arc_count_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_arc_count_get;
*swig_arc_count_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_arc_count_set;
*swig_cur_byte_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_cur_byte_get;
*swig_cur_byte_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_cur_byte_set;
*swig_last_header_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_last_header_get;
*swig_last_header_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_last_header_set;
*swig_next_header_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_next_header_get;
*swig_next_header_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_next_header_set;
*swig_cur_state_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_cur_state_get;
*swig_cur_state_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_cur_state_set;
*swig_state_stack_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_state_stack_get;
*swig_state_stack_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_state_stack_set;
*swig_attributes_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_attributes_get;
*swig_attributes_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_attributes_set;
*swig_attribute_count_get = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_attribute_count_get;
*swig_attribute_count_set = *Lingua::XFST::Privatesc::FST_CNTXT_bin_io_attribute_count_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT_bin_io(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT_bin_io($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT_parse ##############

package Lingua::XFST::Privates::FST_CNTXT_parse;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_ignore_white_space_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_ignore_white_space_p_get;
*swig_ignore_white_space_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_ignore_white_space_p_set;
*swig_zero_to_epsilon_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_zero_to_epsilon_p_get;
*swig_zero_to_epsilon_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_zero_to_epsilon_p_set;
*swig_input_seq_size_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_input_seq_size_get;
*swig_input_seq_size_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_input_seq_size_set;
*swig_input_seq_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_input_seq_get;
*swig_input_seq_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_input_seq_set;
*swig_lower_match_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_lower_match_get;
*swig_lower_match_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_lower_match_set;
*swig_match_table_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_match_table_get;
*swig_match_table_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_match_table_set;
*swig_upper_match_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_upper_match_get;
*swig_upper_match_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_upper_match_set;
*swig_obsolete_parse_tables_get = *Lingua::XFST::Privatesc::FST_CNTXT_parse_obsolete_parse_tables_get;
*swig_obsolete_parse_tables_set = *Lingua::XFST::Privatesc::FST_CNTXT_parse_obsolete_parse_tables_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT_parse(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT_parse($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT_index ##############

package Lingua::XFST::Privates::FST_CNTXT_index;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_max_path_index_pos_get = *Lingua::XFST::Privatesc::FST_CNTXT_index_max_path_index_pos_get;
*swig_max_path_index_pos_set = *Lingua::XFST::Privatesc::FST_CNTXT_index_max_path_index_pos_set;
*swig_path_index_incr_get = *Lingua::XFST::Privatesc::FST_CNTXT_index_path_index_incr_get;
*swig_path_index_incr_set = *Lingua::XFST::Privatesc::FST_CNTXT_index_path_index_incr_set;
*swig_path_index_pos_get = *Lingua::XFST::Privatesc::FST_CNTXT_index_path_index_pos_get;
*swig_path_index_pos_set = *Lingua::XFST::Privatesc::FST_CNTXT_index_path_index_pos_set;
*swig_path_index_vector_get = *Lingua::XFST::Privatesc::FST_CNTXT_index_path_index_vector_get;
*swig_path_index_vector_set = *Lingua::XFST::Privatesc::FST_CNTXT_index_path_index_vector_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT_index(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT_index($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT_pretty_print ##############

package Lingua::XFST::Privates::FST_CNTXT_pretty_print;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_cur_pos_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_cur_pos_get;
*swig_cur_pos_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_cur_pos_set;
*swig_indent_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_indent_get;
*swig_indent_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_indent_set;
*swig_line_pos_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_line_pos_get;
*swig_line_pos_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_line_pos_set;
*swig_output_buffer_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_output_buffer_get;
*swig_output_buffer_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_output_buffer_set;
*swig_output_buffer_size_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_output_buffer_size_get;
*swig_output_buffer_size_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_output_buffer_size_set;
*swig_right_margin_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_right_margin_get;
*swig_right_margin_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_right_margin_set;
*swig_eol_string_get = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_eol_string_get;
*swig_eol_string_set = *Lingua::XFST::Privatesc::FST_CNTXT_pretty_print_eol_string_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT_pretty_print(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT_pretty_print($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT_flags ##############

package Lingua::XFST::Privates::FST_CNTXT_flags;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_keep_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_flags_keep_p_get;
*swig_keep_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_flags_keep_p_set;
*swig_determinize_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_flags_determinize_p_get;
*swig_determinize_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_flags_determinize_p_set;
*swig_minimize_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_flags_minimize_p_get;
*swig_minimize_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_flags_minimize_p_set;
*swig_prune_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_flags_prune_p_get;
*swig_prune_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_flags_prune_p_set;
*swig_reclaim_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_flags_reclaim_p_get;
*swig_reclaim_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_flags_reclaim_p_set;
*swig_embedded_command_p_get = *Lingua::XFST::Privatesc::FST_CNTXT_flags_embedded_command_p_get;
*swig_embedded_command_p_set = *Lingua::XFST::Privatesc::FST_CNTXT_flags_embedded_command_p_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT_flags(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT_flags($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::FST_CNTXT_temp_bufs ##############

package Lingua::XFST::Privates::FST_CNTXT_temp_bufs;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_string_buffer_get = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_string_buffer_get;
*swig_string_buffer_set = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_string_buffer_set;
*swig_fat_str_buffer_get = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_fat_str_buffer_get;
*swig_fat_str_buffer_set = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_fat_str_buffer_set;
*swig_page_buffer_get = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_page_buffer_get;
*swig_page_buffer_set = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_page_buffer_set;
*swig_lab_vector_get = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_lab_vector_get;
*swig_lab_vector_set = *Lingua::XFST::Privatesc::FST_CNTXT_temp_bufs_lab_vector_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_FST_CNTXT_temp_bufs(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_FST_CNTXT_temp_bufs($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::XFST::Privates::APPLYtype ##############

package Lingua::XFST::Privates::APPLYtype;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::XFST::Privates );
%OWNER = ();
%ITERATORS = ();
*swig_reclaimable_get = *Lingua::XFST::Privatesc::APPLYtype_reclaimable_get;
*swig_reclaimable_set = *Lingua::XFST::Privatesc::APPLYtype_reclaimable_set;
*swig_net1_get = *Lingua::XFST::Privatesc::APPLYtype_net1_get;
*swig_net1_set = *Lingua::XFST::Privatesc::APPLYtype_net1_set;
*swig_net2_get = *Lingua::XFST::Privatesc::APPLYtype_net2_get;
*swig_net2_set = *Lingua::XFST::Privatesc::APPLYtype_net2_set;
*swig_net_vector_get = *Lingua::XFST::Privatesc::APPLYtype_net_vector_get;
*swig_net_vector_set = *Lingua::XFST::Privatesc::APPLYtype_net_vector_set;
*swig_side_get = *Lingua::XFST::Privatesc::APPLYtype_side_get;
*swig_side_set = *Lingua::XFST::Privatesc::APPLYtype_side_set;
*swig_out_side_get = *Lingua::XFST::Privatesc::APPLYtype_out_side_get;
*swig_out_side_set = *Lingua::XFST::Privatesc::APPLYtype_out_side_set;
*swig_obey_flags_p_get = *Lingua::XFST::Privatesc::APPLYtype_obey_flags_p_get;
*swig_obey_flags_p_set = *Lingua::XFST::Privatesc::APPLYtype_obey_flags_p_set;
*swig_print_space_p_get = *Lingua::XFST::Privatesc::APPLYtype_print_space_p_get;
*swig_print_space_p_set = *Lingua::XFST::Privatesc::APPLYtype_print_space_p_set;
*swig_show_flags_p_get = *Lingua::XFST::Privatesc::APPLYtype_show_flags_p_get;
*swig_show_flags_p_set = *Lingua::XFST::Privatesc::APPLYtype_show_flags_p_set;
*swig_flags_p_get = *Lingua::XFST::Privatesc::APPLYtype_flags_p_get;
*swig_flags_p_set = *Lingua::XFST::Privatesc::APPLYtype_flags_p_set;
*swig_recursive_p_get = *Lingua::XFST::Privatesc::APPLYtype_recursive_p_get;
*swig_recursive_p_set = *Lingua::XFST::Privatesc::APPLYtype_recursive_p_set;
*swig_eol_is_eof_p_get = *Lingua::XFST::Privatesc::APPLYtype_eol_is_eof_p_get;
*swig_eol_is_eof_p_set = *Lingua::XFST::Privatesc::APPLYtype_eol_is_eof_p_set;
*swig_next_input_line_p_get = *Lingua::XFST::Privatesc::APPLYtype_next_input_line_p_get;
*swig_next_input_line_p_set = *Lingua::XFST::Privatesc::APPLYtype_next_input_line_p_set;
*swig_need_separators_p_get = *Lingua::XFST::Privatesc::APPLYtype_need_separators_p_get;
*swig_need_separators_p_set = *Lingua::XFST::Privatesc::APPLYtype_need_separators_p_set;
*swig_count_patterns_p_get = *Lingua::XFST::Privatesc::APPLYtype_count_patterns_p_get;
*swig_count_patterns_p_set = *Lingua::XFST::Privatesc::APPLYtype_count_patterns_p_set;
*swig_delete_patterns_p_get = *Lingua::XFST::Privatesc::APPLYtype_delete_patterns_p_get;
*swig_delete_patterns_p_set = *Lingua::XFST::Privatesc::APPLYtype_delete_patterns_p_set;
*swig_extract_patterns_p_get = *Lingua::XFST::Privatesc::APPLYtype_extract_patterns_p_get;
*swig_extract_patterns_p_set = *Lingua::XFST::Privatesc::APPLYtype_extract_patterns_p_set;
*swig_locate_patterns_p_get = *Lingua::XFST::Privatesc::APPLYtype_locate_patterns_p_get;
*swig_locate_patterns_p_set = *Lingua::XFST::Privatesc::APPLYtype_locate_patterns_p_set;
*swig_one_tag_per_line_p_get = *Lingua::XFST::Privatesc::APPLYtype_one_tag_per_line_p_get;
*swig_one_tag_per_line_p_set = *Lingua::XFST::Privatesc::APPLYtype_one_tag_per_line_p_set;
*swig_mark_patterns_p_get = *Lingua::XFST::Privatesc::APPLYtype_mark_patterns_p_get;
*swig_mark_patterns_p_set = *Lingua::XFST::Privatesc::APPLYtype_mark_patterns_p_set;
*swig_max_context_length_get = *Lingua::XFST::Privatesc::APPLYtype_max_context_length_get;
*swig_max_context_length_set = *Lingua::XFST::Privatesc::APPLYtype_max_context_length_set;
*swig_in_pos_get = *Lingua::XFST::Privatesc::APPLYtype_in_pos_get;
*swig_in_pos_set = *Lingua::XFST::Privatesc::APPLYtype_in_pos_set;
*swig_end_pos_get = *Lingua::XFST::Privatesc::APPLYtype_end_pos_get;
*swig_end_pos_set = *Lingua::XFST::Privatesc::APPLYtype_end_pos_set;
*swig_nv_pos_get = *Lingua::XFST::Privatesc::APPLYtype_nv_pos_get;
*swig_nv_pos_set = *Lingua::XFST::Privatesc::APPLYtype_nv_pos_set;
*swig_level_get = *Lingua::XFST::Privatesc::APPLYtype_level_get;
*swig_level_set = *Lingua::XFST::Privatesc::APPLYtype_level_set;
*swig_depth_get = *Lingua::XFST::Privatesc::APPLYtype_depth_get;
*swig_depth_set = *Lingua::XFST::Privatesc::APPLYtype_depth_set;
*swig_num_inputs_get = *Lingua::XFST::Privatesc::APPLYtype_num_inputs_get;
*swig_num_inputs_set = *Lingua::XFST::Privatesc::APPLYtype_num_inputs_set;
*swig_eol_string_get = *Lingua::XFST::Privatesc::APPLYtype_eol_string_get;
*swig_eol_string_set = *Lingua::XFST::Privatesc::APPLYtype_eol_string_set;
*swig_end_of_input_get = *Lingua::XFST::Privatesc::APPLYtype_end_of_input_get;
*swig_end_of_input_set = *Lingua::XFST::Privatesc::APPLYtype_end_of_input_set;
*swig_longest_match_get = *Lingua::XFST::Privatesc::APPLYtype_longest_match_get;
*swig_longest_match_set = *Lingua::XFST::Privatesc::APPLYtype_longest_match_set;
*swig_max_recursion_depth_get = *Lingua::XFST::Privatesc::APPLYtype_max_recursion_depth_get;
*swig_max_recursion_depth_set = *Lingua::XFST::Privatesc::APPLYtype_max_recursion_depth_set;
*swig_parse_table_get = *Lingua::XFST::Privatesc::APPLYtype_parse_table_get;
*swig_parse_table_set = *Lingua::XFST::Privatesc::APPLYtype_parse_table_set;
*swig_next_symbol_fn_get = *Lingua::XFST::Privatesc::APPLYtype_next_symbol_fn_get;
*swig_next_symbol_fn_set = *Lingua::XFST::Privatesc::APPLYtype_next_symbol_fn_set;
*swig_write_buffer_fn_get = *Lingua::XFST::Privatesc::APPLYtype_write_buffer_fn_get;
*swig_write_buffer_fn_set = *Lingua::XFST::Privatesc::APPLYtype_write_buffer_fn_set;
*swig_in_fn_get = *Lingua::XFST::Privatesc::APPLYtype_in_fn_get;
*swig_in_fn_set = *Lingua::XFST::Privatesc::APPLYtype_in_fn_set;
*swig_out_fn_get = *Lingua::XFST::Privatesc::APPLYtype_out_fn_get;
*swig_out_fn_set = *Lingua::XFST::Privatesc::APPLYtype_out_fn_set;
*swig_prev_sym_get = *Lingua::XFST::Privatesc::APPLYtype_prev_sym_get;
*swig_prev_sym_set = *Lingua::XFST::Privatesc::APPLYtype_prev_sym_set;
*swig_match_table_get = *Lingua::XFST::Privatesc::APPLYtype_match_table_get;
*swig_match_table_set = *Lingua::XFST::Privatesc::APPLYtype_match_table_set;
*swig_input_get = *Lingua::XFST::Privatesc::APPLYtype_input_get;
*swig_input_set = *Lingua::XFST::Privatesc::APPLYtype_input_set;
*swig_remainder_get = *Lingua::XFST::Privatesc::APPLYtype_remainder_get;
*swig_remainder_set = *Lingua::XFST::Privatesc::APPLYtype_remainder_set;
*swig_in_stream_get = *Lingua::XFST::Privatesc::APPLYtype_in_stream_get;
*swig_in_stream_set = *Lingua::XFST::Privatesc::APPLYtype_in_stream_set;
*swig_out_stream_get = *Lingua::XFST::Privatesc::APPLYtype_out_stream_get;
*swig_out_stream_set = *Lingua::XFST::Privatesc::APPLYtype_out_stream_set;
*swig_in_data_get = *Lingua::XFST::Privatesc::APPLYtype_in_data_get;
*swig_in_data_set = *Lingua::XFST::Privatesc::APPLYtype_in_data_set;
*swig_out_data_get = *Lingua::XFST::Privatesc::APPLYtype_out_data_get;
*swig_out_data_set = *Lingua::XFST::Privatesc::APPLYtype_out_data_set;
*swig_out_count_get = *Lingua::XFST::Privatesc::APPLYtype_out_count_get;
*swig_out_count_set = *Lingua::XFST::Privatesc::APPLYtype_out_count_set;
*swig_output_fn_get = *Lingua::XFST::Privatesc::APPLYtype_output_fn_get;
*swig_output_fn_set = *Lingua::XFST::Privatesc::APPLYtype_output_fn_set;
*swig_in_vector_get = *Lingua::XFST::Privatesc::APPLYtype_in_vector_get;
*swig_in_vector_set = *Lingua::XFST::Privatesc::APPLYtype_in_vector_set;
*swig_mid_vector_get = *Lingua::XFST::Privatesc::APPLYtype_mid_vector_get;
*swig_mid_vector_set = *Lingua::XFST::Privatesc::APPLYtype_mid_vector_set;
*swig_out_vector_get = *Lingua::XFST::Privatesc::APPLYtype_out_vector_get;
*swig_out_vector_set = *Lingua::XFST::Privatesc::APPLYtype_out_vector_set;
*swig_in_table_get = *Lingua::XFST::Privatesc::APPLYtype_in_table_get;
*swig_in_table_set = *Lingua::XFST::Privatesc::APPLYtype_in_table_set;
*swig_out_table_get = *Lingua::XFST::Privatesc::APPLYtype_out_table_get;
*swig_out_table_set = *Lingua::XFST::Privatesc::APPLYtype_out_table_set;
*swig_sigma_get = *Lingua::XFST::Privatesc::APPLYtype_sigma_get;
*swig_sigma_set = *Lingua::XFST::Privatesc::APPLYtype_sigma_set;
*swig_prev_sigma_get = *Lingua::XFST::Privatesc::APPLYtype_prev_sigma_get;
*swig_prev_sigma_set = *Lingua::XFST::Privatesc::APPLYtype_prev_sigma_set;
*swig_host_net_vector_get = *Lingua::XFST::Privatesc::APPLYtype_host_net_vector_get;
*swig_host_net_vector_set = *Lingua::XFST::Privatesc::APPLYtype_host_net_vector_set;
*swig_flag_register_get = *Lingua::XFST::Privatesc::APPLYtype_flag_register_get;
*swig_flag_register_set = *Lingua::XFST::Privatesc::APPLYtype_flag_register_set;
*swig_flag_vector_get = *Lingua::XFST::Privatesc::APPLYtype_flag_vector_get;
*swig_flag_vector_set = *Lingua::XFST::Privatesc::APPLYtype_flag_vector_set;
*swig_tag_vector_get = *Lingua::XFST::Privatesc::APPLYtype_tag_vector_get;
*swig_tag_vector_set = *Lingua::XFST::Privatesc::APPLYtype_tag_vector_set;
*swig_arc_vector_get = *Lingua::XFST::Privatesc::APPLYtype_arc_vector_get;
*swig_arc_vector_set = *Lingua::XFST::Privatesc::APPLYtype_arc_vector_set;
*swig_state_vector_get = *Lingua::XFST::Privatesc::APPLYtype_state_vector_get;
*swig_state_vector_set = *Lingua::XFST::Privatesc::APPLYtype_state_vector_set;
*swig_destination_vector_get = *Lingua::XFST::Privatesc::APPLYtype_destination_vector_get;
*swig_destination_vector_set = *Lingua::XFST::Privatesc::APPLYtype_destination_vector_set;
*swig_start_vector_get = *Lingua::XFST::Privatesc::APPLYtype_start_vector_get;
*swig_start_vector_set = *Lingua::XFST::Privatesc::APPLYtype_start_vector_set;
*swig_task_vector_get = *Lingua::XFST::Privatesc::APPLYtype_task_vector_get;
*swig_task_vector_set = *Lingua::XFST::Privatesc::APPLYtype_task_vector_set;
*swig_pos_table_get = *Lingua::XFST::Privatesc::APPLYtype_pos_table_get;
*swig_pos_table_set = *Lingua::XFST::Privatesc::APPLYtype_pos_table_set;
*swig_in_buffer_get = *Lingua::XFST::Privatesc::APPLYtype_in_buffer_get;
*swig_in_buffer_set = *Lingua::XFST::Privatesc::APPLYtype_in_buffer_set;
*swig_out_buffer_get = *Lingua::XFST::Privatesc::APPLYtype_out_buffer_get;
*swig_out_buffer_set = *Lingua::XFST::Privatesc::APPLYtype_out_buffer_set;
*swig_save_buffer_get = *Lingua::XFST::Privatesc::APPLYtype_save_buffer_get;
*swig_save_buffer_set = *Lingua::XFST::Privatesc::APPLYtype_save_buffer_set;
*swig_hyper_unit_get = *Lingua::XFST::Privatesc::APPLYtype_hyper_unit_get;
*swig_hyper_unit_set = *Lingua::XFST::Privatesc::APPLYtype_hyper_unit_set;
*swig_file_pos_get = *Lingua::XFST::Privatesc::APPLYtype_file_pos_get;
*swig_file_pos_set = *Lingua::XFST::Privatesc::APPLYtype_file_pos_set;
*swig_other_than_vector_get = *Lingua::XFST::Privatesc::APPLYtype_other_than_vector_get;
*swig_other_than_vector_set = *Lingua::XFST::Privatesc::APPLYtype_other_than_vector_set;
*swig_in_seq_get = *Lingua::XFST::Privatesc::APPLYtype_in_seq_get;
*swig_in_seq_set = *Lingua::XFST::Privatesc::APPLYtype_in_seq_set;
*swig_out_seq_get = *Lingua::XFST::Privatesc::APPLYtype_out_seq_get;
*swig_out_seq_set = *Lingua::XFST::Privatesc::APPLYtype_out_seq_set;
*swig_input_table_get = *Lingua::XFST::Privatesc::APPLYtype_input_table_get;
*swig_input_table_set = *Lingua::XFST::Privatesc::APPLYtype_input_table_set;
*swig_output_table_get = *Lingua::XFST::Privatesc::APPLYtype_output_table_get;
*swig_output_table_set = *Lingua::XFST::Privatesc::APPLYtype_output_table_set;
*swig_start_state_fn_get = *Lingua::XFST::Privatesc::APPLYtype_start_state_fn_get;
*swig_start_state_fn_set = *Lingua::XFST::Privatesc::APPLYtype_start_state_fn_set;
*swig_label_from_arc_fn_get = *Lingua::XFST::Privatesc::APPLYtype_label_from_arc_fn_get;
*swig_label_from_arc_fn_set = *Lingua::XFST::Privatesc::APPLYtype_label_from_arc_fn_set;
*swig_next_arc_fn_get = *Lingua::XFST::Privatesc::APPLYtype_next_arc_fn_get;
*swig_next_arc_fn_set = *Lingua::XFST::Privatesc::APPLYtype_next_arc_fn_set;
*swig_destination_fn_get = *Lingua::XFST::Privatesc::APPLYtype_destination_fn_get;
*swig_destination_fn_set = *Lingua::XFST::Privatesc::APPLYtype_destination_fn_set;
*swig_solution_tree_get = *Lingua::XFST::Privatesc::APPLYtype_solution_tree_get;
*swig_solution_tree_set = *Lingua::XFST::Privatesc::APPLYtype_solution_tree_set;
*swig_input_ring_get = *Lingua::XFST::Privatesc::APPLYtype_input_ring_get;
*swig_input_ring_set = *Lingua::XFST::Privatesc::APPLYtype_input_ring_set;
*swig_location_path_get = *Lingua::XFST::Privatesc::APPLYtype_location_path_get;
*swig_location_path_set = *Lingua::XFST::Privatesc::APPLYtype_location_path_set;
*swig_location_path_length_get = *Lingua::XFST::Privatesc::APPLYtype_location_path_length_get;
*swig_location_path_length_set = *Lingua::XFST::Privatesc::APPLYtype_location_path_length_set;
*swig_task_heap_get = *Lingua::XFST::Privatesc::APPLYtype_task_heap_get;
*swig_task_heap_set = *Lingua::XFST::Privatesc::APPLYtype_task_heap_set;
*swig_task_stack_get = *Lingua::XFST::Privatesc::APPLYtype_task_stack_get;
*swig_task_stack_set = *Lingua::XFST::Privatesc::APPLYtype_task_stack_set;
*swig_state_get = *Lingua::XFST::Privatesc::APPLYtype_state_get;
*swig_state_set = *Lingua::XFST::Privatesc::APPLYtype_state_set;
*swig_arc_it_get = *Lingua::XFST::Privatesc::APPLYtype_arc_it_get;
*swig_arc_it_set = *Lingua::XFST::Privatesc::APPLYtype_arc_it_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::XFST::Privatesc::new_APPLYtype(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::XFST::Privatesc::delete_APPLYtype($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- CONSTANT STUBS -------

package Lingua::XFST::Privates;

sub TRUE () { $Lingua::XFST::Privatesc::TRUE }
sub FALSE () { $Lingua::XFST::Privatesc::FALSE }
sub EPSILON () { $Lingua::XFST::Privatesc::EPSILON }
sub OTHER () { $Lingua::XFST::Privatesc::OTHER }
sub UPPER () { $Lingua::XFST::Privatesc::UPPER }
sub LOWER () { $Lingua::XFST::Privatesc::LOWER }
sub BOTH_SIDES () { $Lingua::XFST::Privatesc::BOTH_SIDES }
sub NOT_VISITED () { $Lingua::XFST::Privatesc::NOT_VISITED }
sub IN_PROCESS () { $Lingua::XFST::Privatesc::IN_PROCESS }
sub DONE () { $Lingua::XFST::Privatesc::DONE }
sub DONT_ESCAPE () { $Lingua::XFST::Privatesc::DONT_ESCAPE }
sub ESCAPE () { $Lingua::XFST::Privatesc::ESCAPE }
sub DONT_OBEY () { $Lingua::XFST::Privatesc::DONT_OBEY }
sub OBEY () { $Lingua::XFST::Privatesc::OBEY }
sub DONT_KEEP () { $Lingua::XFST::Privatesc::DONT_KEEP }
sub KEEP () { $Lingua::XFST::Privatesc::KEEP }
sub CHAR_ENC_UNKNOWN () { $Lingua::XFST::Privatesc::CHAR_ENC_UNKNOWN }
sub CHAR_ENC_UTF_8 () { $Lingua::XFST::Privatesc::CHAR_ENC_UTF_8 }
sub CHAR_ENC_ISO_8859_1 () { $Lingua::XFST::Privatesc::CHAR_ENC_ISO_8859_1 }
sub BINARY_VECTOR () { $Lingua::XFST::Privatesc::BINARY_VECTOR }
sub LABEL_VECTOR () { $Lingua::XFST::Privatesc::LABEL_VECTOR }
sub DONT_WATCH_RM () { $Lingua::XFST::Privatesc::DONT_WATCH_RM }
sub WATCH_RM () { $Lingua::XFST::Privatesc::WATCH_RM }
sub DONT_RECORD () { $Lingua::XFST::Privatesc::DONT_RECORD }
sub RECORD () { $Lingua::XFST::Privatesc::RECORD }
sub NO_ACTION () { $Lingua::XFST::Privatesc::NO_ACTION }
sub CLEAR_SETTING () { $Lingua::XFST::Privatesc::CLEAR_SETTING }
sub POSITIVE_SETTING () { $Lingua::XFST::Privatesc::POSITIVE_SETTING }
sub NEGATIVE_SETTING () { $Lingua::XFST::Privatesc::NEGATIVE_SETTING }
sub UNIFY_TEST () { $Lingua::XFST::Privatesc::UNIFY_TEST }
sub DISALLOW_TEST () { $Lingua::XFST::Privatesc::DISALLOW_TEST }
sub REQUIRE_TEST () { $Lingua::XFST::Privatesc::REQUIRE_TEST }
sub FAIL_ACTION () { $Lingua::XFST::Privatesc::FAIL_ACTION }
sub INSERT_SUBNET () { $Lingua::XFST::Privatesc::INSERT_SUBNET }
sub SET_TO_ATTR () { $Lingua::XFST::Privatesc::SET_TO_ATTR }
sub EQUAL_ATTR_TEST () { $Lingua::XFST::Privatesc::EQUAL_ATTR_TEST }
sub LIST_MEMBER () { $Lingua::XFST::Privatesc::LIST_MEMBER }
sub APPLY_TRANSDUCER () { $Lingua::XFST::Privatesc::APPLY_TRANSDUCER }
sub APPLY_FUNCTION () { $Lingua::XFST::Privatesc::APPLY_FUNCTION }
sub EXCLUDE_LIST () { $Lingua::XFST::Privatesc::EXCLUDE_LIST }
sub Unknown () { $Lingua::XFST::Privatesc::Unknown }
sub Network () { $Lingua::XFST::Privatesc::Network }
sub Alphabet () { $Lingua::XFST::Privatesc::Alphabet }
sub Integer () { $Lingua::XFST::Privatesc::Integer }
sub Other () { $Lingua::XFST::Privatesc::Other }
sub NUM_BYTES () { $Lingua::XFST::Privatesc::NUM_BYTES }
sub NUM_CHARS () { $Lingua::XFST::Privatesc::NUM_CHARS }
sub MAX_LV () { $Lingua::XFST::Privatesc::MAX_LV }

# ------- VARIABLE STUBS --------

package Lingua::XFST::Privates;

1;
